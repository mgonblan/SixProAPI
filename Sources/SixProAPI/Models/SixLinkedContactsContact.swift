//
// SixLinkedContactsContact.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import AnyCodable

public struct SixLinkedContactsContact: Codable, Hashable {

    public var id: UUID?
    public var creationTime: Date?
    public var creatorId: UUID?
    public var lastModificationTime: Date?
    public var lastModifierId: UUID?
    public var isDeleted: Bool?
    public var deleterId: UUID?
    public var deletionTime: Date?
    public var userId: UUID?
    public var user: SixLinkedUsersAppUser?
    public var companyId: UUID?
    public var company: SixLinkedCompaniesCompany?
    public var contactUserId: UUID?
    public var contactUser: SixLinkedUsersAppUser?
    public var contactCompanyId: UUID?
    public var contactCompany: SixLinkedCompaniesCompany?
    public var type: SixLinkedContactsContactType?
    public var publications: [SixLinkedPublicationsPublication]?

    public init(id: UUID? = nil, creationTime: Date? = nil, creatorId: UUID? = nil, lastModificationTime: Date? = nil, lastModifierId: UUID? = nil, isDeleted: Bool? = nil, deleterId: UUID? = nil, deletionTime: Date? = nil, userId: UUID? = nil, user: SixLinkedUsersAppUser? = nil, companyId: UUID? = nil, company: SixLinkedCompaniesCompany? = nil, contactUserId: UUID? = nil, contactUser: SixLinkedUsersAppUser? = nil, contactCompanyId: UUID? = nil, contactCompany: SixLinkedCompaniesCompany? = nil, type: SixLinkedContactsContactType? = nil, publications: [SixLinkedPublicationsPublication]? = nil) {
        self.id = id
        self.creationTime = creationTime
        self.creatorId = creatorId
        self.lastModificationTime = lastModificationTime
        self.lastModifierId = lastModifierId
        self.isDeleted = isDeleted
        self.deleterId = deleterId
        self.deletionTime = deletionTime
        self.userId = userId
        self.user = user
        self.companyId = companyId
        self.company = company
        self.contactUserId = contactUserId
        self.contactUser = contactUser
        self.contactCompanyId = contactCompanyId
        self.contactCompany = contactCompany
        self.type = type
        self.publications = publications
    }
    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case creationTime
        case creatorId
        case lastModificationTime
        case lastModifierId
        case isDeleted
        case deleterId
        case deletionTime
        case userId
        case user
        case companyId
        case company
        case contactUserId
        case contactUser
        case contactCompanyId
        case contactCompany
        case type
        case publications
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(creationTime, forKey: .creationTime)
        try container.encodeIfPresent(creatorId, forKey: .creatorId)
        try container.encodeIfPresent(lastModificationTime, forKey: .lastModificationTime)
        try container.encodeIfPresent(lastModifierId, forKey: .lastModifierId)
        try container.encodeIfPresent(isDeleted, forKey: .isDeleted)
        try container.encodeIfPresent(deleterId, forKey: .deleterId)
        try container.encodeIfPresent(deletionTime, forKey: .deletionTime)
        try container.encodeIfPresent(userId, forKey: .userId)
        try container.encodeIfPresent(user, forKey: .user)
        try container.encodeIfPresent(companyId, forKey: .companyId)
        try container.encodeIfPresent(company, forKey: .company)
        try container.encodeIfPresent(contactUserId, forKey: .contactUserId)
        try container.encodeIfPresent(contactUser, forKey: .contactUser)
        try container.encodeIfPresent(contactCompanyId, forKey: .contactCompanyId)
        try container.encodeIfPresent(contactCompany, forKey: .contactCompany)
        try container.encodeIfPresent(type, forKey: .type)
        try container.encodeIfPresent(publications, forKey: .publications)
    }



}
